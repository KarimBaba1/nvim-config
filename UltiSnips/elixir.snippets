# snippet pry "pry" b
# require IEx; Task.start_link(fn -> System.cmd("focus-elixir-pry", []) end); IEx.pry
# endsnippet

snippet pry "pry" b
require IEx; Task.start_link(fn -> System.cmd("curl", ["-s", "http://`my-docker-gateway`:32323/elixir-pry"]) end); IEx.pry
endsnippet

snippet /fn/ "fn" r
fn(x) -> x end
endsnippet

snippet defm "defmodule" b
defmodule $1 do
  @moduledoc """
  Description
  """

  $0
end
endsnippet

snippet def "def" b
def $1 do
  $0
end
endsnippet

snippet @doc "@doc" b
@doc ~S"""
Description

## Examples

    iex> 1
    1

"""
endsnippet


snippet /for/ "comprehension" r
for {key, val} <- $0,
  into: %{} do
  {key, val * val}
end
endsnippet

snippet with "with statement" b
with account_name <- auth.extra.raw_info["account_name"],
		 {:ok} <- repo |> account_not_exist?(account_name),
		 {:ok, account} <- create_account(auth, repo),
		 {:ok, user} <- create_user(auth, repo, account.id),
		 {:ok, auth} <- authorization_from_auth(user, auth, repo) do
	{:ok, user}
else
	{:error, _} -> {:error, "Something went wrong"}
end
endsnippet

snippet echo "IO.puts" b
IO.puts Poison.encode!($0)
endsnippet

snippet base "base layout" b
defmodule Test do
  @moduledoc """
  Description
  """

  def test do
    IO.puts "hello"
  end
end

Test.test
endsnippet


snippet genserver "new gen server" b
defmodule ${1:Project.GenServerName} do
  # put in your supervisor tree
  # worker($1, [])

  use GenServer

  def start_link(args) do
    GenServer.start_link(__MODULE__, args, [])
  end

  def hi(server) do
    GenServer.call(server, {:hi})
  end

  # Server implementation

  def init([]) do
    # {:ok, initial-state}
    {:ok, []}
  end

  def handle_call({:hi}, _from, state) do
    {:reply, {:ok, :hi}, state}
  end

end
endsnippet

snippet case "Case" b
case {1, 2, 3} do
  {4, 5, 6} ->
    "This clause won't match"
  {1, x, 3} ->
    "This clause will match and bind x to 2 in this clause"
  _ ->
    "This clause would match any value"
end
endsnippet

snippet sleep "sleep" b
:timer.sleep(1000)
endsnippet

snippet tran "mnesia transaction" b
:mnesia.transaction(fn ->
  $0
end)
endsnippet

snippet /each/ "Enum.each" r
Enum.each($0, fn(item) ->
end)
endsnippet

snippet /map/ "Enum.map" r
Enum.map($0, fn(item) ->
end)
endsnippet

snippet /reduce/ "Enum.reduce" r
Enum.reduce($0, initial_val, fn(item, acc) ->
  item + acc
end)
endsnippet

snippet /Enum.map/ "Enum.map" r
Enum.map($0, fn(x) -> x * 2 end)
endsnippet

snippet try "try catch" b
try do
	$0
rescue
  e in RuntimeError -> e
end
endsnippet

snippet todo "todo" b
# @TODO loki, `date +"%d/%m/%Y"`: $0
endsnippet

snippet fixme "fixme" b
# @FIXME loki, `date +"%d/%m/%Y"`: $0
endsnippet
